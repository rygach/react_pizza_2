...11.06 утро

знакомство с курсом, под конец начал терять обладание
первый урок - успел только настроить преттиер, наконец таки он стал форматировать по сохранению

...12.06 проебан 

вечером пошел гулять с Егором и Русланом, а потом встретился с грувом

...13.06 вечер

юсстейт, раскидал html по компонентам, пропсы
допонял, что виртуал дом ебашит виртуальный дом, сравнивает его с настоящим и дорисовывает только то, что изменилось

...14.06 утро
через пропсы добавил картинки, добавил активное состояние кнопок размеров, типов теста, категорий. подтянул с json-файла названия, размеры, типы тест, цены. через spread-оператора слегка сократил код в блоке пиццы при извлечении данных с json-файла. добавил гит, теперь буду после каждого урока коммититься

...15.06 утро
вчера вечером не смог зайти, ёбаный огород
добавили через стейты выделение сортировки, изменение названия span в голове сортировки, и отображение сортировки тоже по стейту. пиздец. за 51 минуту он рассказал только про попап сортировку на сайте и кей....

...16.06 заснул, пиздец бля

...17.06 утро проебал, вечером маленько повозился с vk miniapps

...18, 19, 20.06 нихуя не делал, хотя желание было. как же заебали гулянки с кентами

...21.06 утро
.. https://62afefe0b0a980a2ef469e0b.mockapi.io/items
с утра добил один урок по перестраиванию отрисовки пицц. теперь они подгружаются не с JSON-файла, а с бэка. бэк организован на мокапи - тупо ссылка на ресурс, где в JSON-формате лежит массив объектов. Через fetch запросили их с бека, засунули в стейт items и обернули всё это useEffect'ом. Он позволяет нам отслеживать и отрисовывать приложение только после того, как что-то изменилось.
useEffect треубет большего разбора

Кстати, стал замечать, что мне нужно больше всего в голове держать, чтобы я знал, что у меня имеется в арсенале. Не всё в своем первом проекте я смогу организовать красиво, а что-то вообще не смогу организовать из-за того, что не помню то, что изучал или вообще не изучал такого(не смогу подобрать альтернативу). ТРЕБУЕТ ВНИМАНИЯ

...21.06 вечер
после басика и попытки заполнить путевой сел за реакт. интересный урок про скелетон и реакт-роутер-дом. скрафтили на онлайн-конструкторе скелетон, подогнали его и запустили путем проверки, через useState. сразу после загрузки файлов мы изменяем стейт и в зависимости уже от стейта isLoading отображаем либо скелетон виесто пиццы, либо загруженные пиццы.
реакт роутер не добил, спать охото. с утра надеюсь добью

...22.06 проебан

...23.06 вечер
добил вторую половину 7го урока. Сделали с горем пополам и пережеванными объяснениями роутинг и страницы

...24.06 утро
уфф, через боль я доделал урок по адаптивной верстке. вроде как и интересно, но слишком неподготовленный курс. он прям таааак долго всё разжевывает, иногда даже ошибается и приходится либо смотреть наперед, чтобы не делать лишней работы по исправлению ошибок, либо переделывать вместе с ним.

добили верстку адаптивную, в принципе, ничего больше не было в 8ом уроке. чуть поработал впервые с гридами, но особо ниче не понял

...25-26.06 проебаны. стыдно. хотя... я помогал по дому, а оба вечера посвятил друзьям. спорный момент, скорее всего неправильно поступил

...27.06 вечер
утром не смог встать, хотя стоило попробовать.
урок №9 позади. оформил сортировку пицц и отображение по категориям.
через useEffect мы отслеживаем изменение(нажатие) категории/сортировки. и если изменились, то отрисовываем компонент home заново. при этом отправляем запрос, в который включаем отмеченные сортировку и отмеченную категорию. в сортировку по умолчанию пришлось добавить значение популярности, иначе бы оно оно не отображалось.

плавно Арчаков стал подводить к использованию Редакса, но пока мы перекидывали данные между компонентами с помозью стейтов, которые прокидывали через пропсы. эта тема нежелательна в реакте, в малом приложении это простительно, но вообще PROPS-DRILLENG не катируется

28.06
не помню че делал вообще))) вроде утром немного посидел с 10ым уроком - пагинация и поиск. половину сделал

29.06 утро
утром доделал 10ый урок, теперь имеется поиск и пагинация. пагинация реализована по бичарски - спиздили бомжарскую бибилиотеку без стилей, пришлось настраивать её дольше, чем подключать. а вот поиск оформили пропсдриллингом. пропс дриллинг фиксится в 11ом уроке, уже посмотрел как. на данный момент мы опять же закинули в стейт инпута-поиска в useEffect(стейт пагинации тоже), через него отслеживаем, если изменился, то компонент Home перерисовывается. Стейт поиска создали аж в App.jsx, потому что поиск стоит в хедере, заодно прокидываем стейт и в хоум. В хоум прокидываем, потому что запрос в БД отправляется от туда. В хоум вставляем пропс поиска, который пришел с аппа, в запрос фетч и получаем те пиццы, которые нужны.

30.06 утро
вчера вечером был в басике, ладно, простительно. сегодня утром добил коротенький 11ый урок по useContext. Суть его заключается в том, чтобы убрать пропс дриллинг. У нас он был построен так //App - Header - Search// + //App + Home//. То есть, чтобы мы могли при вводе данных в компонент поиска перекинуть эти данные в хоум, нам нужно было через пропсы связать поиск с хедером(потому что он вложен в него), хедер с эппом и + хоум связать с эппом. И через эпп бы мы просто передавали инфу о том, нужно ли перерисовать хоум(если что-то ввели/вводят в поиск) или не нужно. 
Теперь же у нас есть просто useContext. Его мы создали в эппе, прокинули одну фишку сразу же в серч(минуя хедер), а вторую фишку прокинули в хоум. Теперь они связываются чище. На таком малом проекте как мой, мало заметно, но на больших проектах, пропсдриллинг - плохая вещь.

Насколько я начал понимать, useContext хуже стейт-менеджеров тем, что он ставится на компонент эпп полностью, и от этого перерисовывается всё, что лежит на этом большом компоненте эпп

05.07 утро
redux в фильтрации и сортировке
чето бля расслабился
начали заменять хуки на редакс тул кит. есть ещё вроде редакс обычный, он старый, менее удобный

07.07 утро
пока не забыл, пробую зафиксировать для себя понятие логики работы редакс-тулкит

создаём хранилище - обыный файл, где будут указаны ссылки на все имеющиеся редьюсеры. Редьюсеры хранят в себе состояние конкретного элемента, которое мы отслеживаем и там же хранят метод для его изменения. В целом это называется слайс. Я так понял, редьюсер - часть слайса, потому что в слайсе так же есть и стейт, а не только редьюсер(метод, изменяющий стейт)

пока не до конца допер, как мы подключили редакс-тулкит в хоме и аппжс.

в общем. в хоум мы импортируем с бибилиотеки реакт-редакс два хука - useSelector и useDispatch. Первый отвечает за вытаскивание с хранилища начального стейта в тот компонент, в котором мы хотим использовать этот стейт. А второй хук отвечает за передачу нового состояния в хранилище, в тот нужный слайс.

потом, получается. можно отследить нажатие на кнопку, допустим. и текущий стейт отправить в бд. если нам вдруг нужно сохранять на бд то, что пользователь изменил(потому что стейты будут сбрасываться при перезапуске). в самом слайсе импортировать с бд стейт, чтобы он подгружался от туда. заебатая идея наверное. надо уточнить на форумах

const categoryId = useSelector((state) => state.filter.categoryId);
при отслеживании стейта мы указываем, какой тип слайса нам интересен(.filter), и какой именно стейт от туда отслеживаем(.categoryId)

dispatch(setCategoryId(id));
в зависимости от того, в какой функции будем использовать (при нажатии на кнопку или че) диспатч, будет зависеть её контекстная переменная (id). контекстная переменная в данном случае передается в редьюсер слайса setCategoryId. Его мы импортировали заранее, в строчках, где импортируем в хоум и другие компоненты. (импортировали через декомпозицию или че, короче когда только часть файла импортируем)

так же он показал два расширения для дебага реакта и редакса - отслеживание состояний, выделение компонентов, которые перереисовались и тд

сортировку изменили подобным образом. в компоненте сорт подключили два хука реакт-редакт - useDispatch и useSelector. А так же подключили редьюсер с нашего общего слайлса на фильтрацию. Редьюсер, отвечающий за сортировку setSort.

теперь при клике на выбранный тип сортировки пицц, мы передаем через диспатч в редьюсер нужный элемент, этот элемент записывается в стейт и компонент перерисовывается.

изменили подключение селекторов в хоуме. подключили одной строчкой, чтобы каждый селектор не подрубать в отдельной строке
const { categoryId, sort } = useSelector((state) => state.filter);
но это необязательно, проект небольшой. можно оставить было в две строчки

07.07 вечер
оказывается, useEffect это обычный хук, который работает не от целого компонента, а от только тех стейтов, которые мы прописали в зависимостях(массив в конце). он отслеживает их и при изменении делает то, что нужно

08.07 утро
- заменили фетч запрос на пиццы запросом с бибилиотеки axios. по словам Арчакова, она пизже фетча
- добавили через useRef ссылку на инпут, и в обработчик кнопки крестик-отчистка-инпута засунули ссылку на инпут с фокусом. теперь после очистки инпута, у нас сразу же идёт фокус на инпут, чтобы мы могли вводить новый текст
- пиздец долго допирал, но добавили отсрочку отправки запроса на сервер. сделали через библиотеку Lodash, а именно, метод debounce. чтобы при малейшем изменении стейта инпута не перерисовывался весь компонент и соответственно не пересоздавалась функция updateSearchValue мы обернули эту функцию в useCallback. эта хуйня помогает нам тем, что один раз создала функцию и всё, дальше просто ссылка на неё идёт, хоть и стейты внутри функции будут меняться, у нас нен будет меняться функция и соответственно перерисовываться компонент.

08.07 вечер
добил наконец 14 урок. последним этапом в котором являлось переделывание пагинации через редакс. мы прокинули в хоум новый созданный для пагинации стейт, который хранится в filterSlice. отслеживаем его через наш общий useEffect. если он меняется, то перерисовываем компонент. паралелльно прокидываем его через пропс в компонент пагинации, чтобы там тоже менялось. но меняется пагинация хуй знает как, там ебанутая бибилиотека
на завтрашнее утро планирую добить короткий урок по параметрам URL и раскинуть пару CV в вакансии

11.07-17.07
добил 15 урок по параметрам
суть его заключается в двух добавленных useEffect-ах
! первый юсэф у нас делается при первом рендере(перезагрузке страницы и больше не делается - там нет отслеживаемых параметров). в нем мы сканируем че есть в поисковой строке, если чето есть, то суем это в редакс, чтобы другой юсэф вызвал перерендер из-за их изменения. так же в этом юсэф мы добавили useRef один, чтобы ограничить количество отправляемых запросов в другом юсэф (в котором есть аксиос-запрос)
! во втором добавленном юсэф у нас происходит засовывание в поисковую строку то, че хранится в редаксе. происходит благодаря специальной библиотеке qs. это у нас делается с умом. там мы отслеживаем тоже ref'ом, но другим рендерился у нас компонент хотя бы впервые. если уже рендерился - то разрешаем засовывать в URL то, что хранится в редаксе.
isMounted - тот самый реф, через который мы это отслеживаем, если у нас первый рендер(юсреф создастся в состоянии false), то мы не засовываем ниче в поисковую строку.
! наконец третий юсэф, у нас уже был. мы его подредактировали. он как и раньше отправляет запрос на бэк, забирая от туда пиццы через функцию fetchPizzas и отрисовывает нам их. однако делает это только после проверки ref с первого юсэфа - isSearch. 
получается, запрос в бд отправляется в случаях:
- первый рендер, там по умолчанию useRef - false
- любое изменение стейтов в редаксе - а это любое изменение юрл
! а изменение юрл происходит по нажатию пользователя по кнопкам
СУТЬ ПЕРВОГО ОБЪЯСНЯЕМОГО ЮСЭФ: в нем мы сначала засовываем в переменную то, что хранится в поисковой строке - это на случай, если у нас кто-то ввел ссылку с сортировкой и сразу захотел получить отсортированные пиццы. потом мы создаем отдельную переменную для сортировки - потому что в хранилище, сортировка у нас в виде объекта. поэтому мы через метод .find сравниваем какое свойство сортировки у нас и полностью, вместе с названием засовываем имя и значение сортировки. после этого мы через диспатч, в редьюсер подаём два числа - категорию и страницу, и подаём объект - сортировку, потому что хранится оно у нас в виде объекта - имя и свойство.

Всё, что сделано в 15ом уроке, это либо лайфхаки, либо костыли - если ты профи и можешь сделать лучше. но короче мы понакидали всякой хуйни, немало кода и условий, чтобы у нас все работало по плану. 
Практические весь урок по URL происходил в Home.jsx. Все три useEffect переплетаются и зависят друг от друга. если один закомментить - полетит приложение

18.07
фух бля, 16 урок позади. делал два дня. вчера чет совсем отвлекался
в общем, через ртк поодключили кнопки на PizzaBlock, так же подключили на CartItem кнопочки, подключили кнопку очистки корзины и подключили показатели пицц и суммы - в хедере и в низу корзины.
кнопки подключали через диспатчи, потому что это изменение. для этого мы создали 3 редьюсера - addItem(используется как для первого добавления, так и для последующих, потому что у нас теперь в каждой пицце есть свойство count), removeItem (для удаления пиццы из корзины, удаляет через подтверждение), minusItem (уменьшает счётчик в каждой добавленной пицце по нажатию), clearCart (тупо очищает массив всех пицц)
подробнее за строение редьюсеров распишу в самом слайсе.
так же добавили через условный рендер отображение компонента EmptyCart